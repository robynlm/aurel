

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>aurel.time &mdash; aurel May 2025 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=5a7fad61" />

  
    <link rel="shortcut icon" href="../../_static/favicon.png"/>
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d170800"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            aurel
              <img src="../../_static/aurel.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../source/readme_sections.html">Key Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/readme_sections.html#installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/readme_sections.html#getting-started">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/readme_sections.html#citation">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/advice.html">Working on an HPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/advice.html#convergence">Convergence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/CONTRIBUTING.html">Reporting Issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/CONTRIBUTING.html#code-contributions">Code Contributions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/CONTRIBUTING.html#license">License</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../source/core.html">aurel.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/coresymbolic.html">aurel.coresymbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/finitedifference.html">aurel.finitedifference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/maths.html">aurel.maths</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/numerical.html">aurel.numerical</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/reading.html">aurel.reading</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/time.html">aurel.time</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../source/solutions.html">aurel.solutions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Example.html">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Example_symbolic.html">Example symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Example_over_time.html">Example over time</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/tov_ET.html">tov_ET</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/ICPertFLRW.html">ICPertFLRW</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Schwarzschild_check.html">Schwarzschild check</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Analytic_check.html">Analytic check</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../notebooks/Gravitational_Waves.html">Gravitational Waves</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">aurel</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">aurel.time</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for aurel.time</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Variable calculation and scalar estimation over time for the Aurel package.</span>

<span class="sd">This module provides a function to calculate variables over time series data</span>
<span class="sd">and applying statistical estimation functions to 3D arrays.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">core</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="c1"># Check if running in a notebook</span>
<span class="n">is_notebook</span> <span class="o">=</span> <span class="s1">&#39;ipykernel&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">modules</span>
<span class="c1"># Check if stdout is a terminal (not redirected to a file)</span>
<span class="n">is_terminal</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">isatty</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span> <span class="s1">&#39;isatty&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>
<span class="n">disable_tqdm</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">is_notebook</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_terminal</span>

<span class="c1"># Import appropriate tqdm version</span>
<span class="k">if</span> <span class="n">is_notebook</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm.notebook</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>

<span class="c1"># Dictionary of available estimation functions for 3D arrays</span>
<span class="n">est_functions</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;max&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">,</span>
    <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
    <span class="s1">&#39;quartile1&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">25</span><span class="p">),</span> 
    <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
    <span class="s1">&#39;quartile3&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">75</span><span class="p">),</span>
    <span class="s1">&#39;min&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span>
    <span class="s1">&#39;sum&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span>
    <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">,</span>
    <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">,</span>
    <span class="c1"># Absolute value based functions</span>
    <span class="s1">&#39;maxabs&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="p">)),</span>
    <span class="s1">&#39;minabs&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="p">)),</span>
    <span class="s1">&#39;meanabs&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="p">)),</span>
    <span class="s1">&#39;quartile1abs&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="mi">25</span><span class="p">),</span> 
    <span class="s1">&#39;medianabs&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="mi">50</span><span class="p">),</span>
    <span class="s1">&#39;quartile3abs&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="mi">75</span><span class="p">),</span>
    <span class="s1">&#39;sumabs&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="p">)),</span>
    <span class="s1">&#39;stdabs&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="p">)),</span>
    <span class="s1">&#39;varabs&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">array</span><span class="p">)),</span>
    <span class="c1"># Corner value extractors</span>
    <span class="s1">&#39;x0y0z0&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="s1">&#39;x0y0z1&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="s1">&#39;x0y1z0&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="s1">&#39;x0y1z1&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="s1">&#39;x1y0z0&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="s1">&#39;x1y0z1&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
    <span class="s1">&#39;x1y1z0&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
    <span class="s1">&#39;x1y1z1&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">array</span><span class="p">:</span> <span class="n">array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
<span class="p">}</span>

<div class="viewcode-block" id="over_time">
<a class="viewcode-back" href="../../source/time.html#aurel.time.over_time">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">over_time</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="nb">vars</span><span class="o">=</span><span class="p">[],</span> <span class="n">estimates</span><span class="o">=</span><span class="p">[],</span> 
              <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">veryverbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">rel_kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate variables from the data and store them in the data dictionary.</span>
<span class="sd">    </span>
<span class="sd">    This function processes time series data by creating AurelCore instances </span>
<span class="sd">    for each time step, calculating specified variables, and optionally </span>
<span class="sd">    applying estimation functions to 3D arrays.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : dict</span>
<span class="sd">        Dictionary containing time series data. Must include an &#39;it&#39; key with</span>
<span class="sd">        iteration information. This function will add calculated variables</span>
<span class="sd">        to this dictionary.</span>
<span class="sd">    fd : FiniteDifference</span>
<span class="sd">        Finite difference class used to initialize AurelCore instances.</span>
<span class="sd">    vars : list of str or dict, optional</span>
<span class="sd">        List of variable names to calculate. These variables will be computed</span>
<span class="sd">        using the AurelCore instance at each time step.</span>
<span class="sd">        Elements can be:</span>

<span class="sd">        - str: Names of predefined variables from core.descriptions</span>
<span class="sd">        - dict: Custom variable definitions with string keys (variable names)</span>
<span class="sd">          and functions that take only an AurelCore instance and return the </span>
<span class="sd">          variable value.</span>

<span class="sd">        Default is an empty list, no variable calculations are performed.</span>
<span class="sd">    estimates : list of str or dict, optional</span>
<span class="sd">        List containing estimation functions to apply to all 3D scalar arrays.</span>
<span class="sd">        Elements can be:</span>

<span class="sd">        - str: Names of predefined functions from est_functions </span>
<span class="sd">          (&#39;max&#39;, &#39;mean&#39;, &#39;median&#39;, &#39;min&#39;, ...)</span>
<span class="sd">        - dict: Custom estimation functions with string keys (function names) </span>
<span class="sd">          and functions that take a scalar 3D array of shape </span>
<span class="sd">          (fd.Nx, fd.Ny, fd.Nz) and return a scalar value.</span>
<span class="sd">        </span>
<span class="sd">        Default is an empty list (no estimation applied).</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        If True, prints debug information about the calculation process.</span>
<span class="sd">    veryverbose : bool, optional</span>
<span class="sd">        If True, provides more detailed debug information. Defaults to False.</span>
<span class="sd">    **rel_kwargs : dict, optional</span>
<span class="sd">        Additional parameters passed to AurelCore initialization, such as:</span>
<span class="sd">        </span>
<span class="sd">        - Lambda : float, cosmological constant</span>
<span class="sd">        - tetrad_to_use : str, tetrad choice for Weyl calculations</span>
<span class="sd">        - any other custom parameters required by user-defined functions.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Updated data dictionary with calculated variables. </span>
<span class="sd">        If `vars` is provided, a new key is added containing a list of </span>
<span class="sd">        values for each time step. </span>
<span class="sd">        If `estimates` is provided, additional keys are added with format </span>
<span class="sd">        &#39;{variable}_{estimation_func}&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check/define temporal key</span>
    <span class="n">temporal_key</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">temp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;it&#39;</span><span class="p">,</span> <span class="s1">&#39;iteration&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">temp</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">temporal_key</span> <span class="o">=</span> <span class="n">temp</span>
    <span class="k">if</span> <span class="n">temporal_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Data dictionary must contain a temporal key: &quot;</span>
                         <span class="s2">&quot;&#39;it&#39;, &#39;iteration&#39;, &#39;t&#39;, or &#39;time&#39;.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Clean vars list to remove any variables that are already in data</span>
    <span class="n">cleaned_vars</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">descriptions</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">cleaned_vars</span> <span class="o">+=</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: Variable &#39;</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s2">&#39; not in core.descriptions,&quot;</span>
                        <span class="o">+</span><span class="s2">&quot; skipping.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># If the variable is a dict, validate each function</span>
            <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">func_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">validate_variable_function</span><span class="p">(</span>
                            <span class="n">function</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span>
                            <span class="n">verbose</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">rel_kwargs</span><span class="p">)</span>
                        <span class="n">cleaned_vars</span> <span class="o">+=</span> <span class="p">[{</span><span class="n">func_name</span><span class="p">:</span> <span class="n">function</span><span class="p">}]</span>
                    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
    <span class="nb">vars</span> <span class="o">=</span> <span class="n">cleaned_vars</span>
    
    <span class="c1"># Clean estimate list to remove any estimations that are already in data</span>
    <span class="n">cleaned_estimates</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">vars</span> <span class="o">!=</span> <span class="p">[]:</span>
        <span class="c1"># Then apply all estimates again</span>
        <span class="k">for</span> <span class="n">est_item</span> <span class="ow">in</span> <span class="n">estimates</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">est_item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># If the estime is a string, check if it is in est_functions</span>
                <span class="c1"># and add it to cleaned_estimates</span>
                <span class="k">if</span> <span class="n">est_item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">est_functions</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                    <span class="n">cleaned_estimates</span> <span class="o">+=</span> <span class="p">[</span><span class="n">est_item</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: Estimation function &#39;</span><span class="si">{</span><span class="n">est_item</span><span class="si">}</span><span class="s2">&#39; not &quot;</span>
                        <span class="o">+</span> <span class="s2">&quot;in est_functions, skipping.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Available functions: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">est_functions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                        <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You can add custom functions&quot;</span>
                        <span class="o">+</span> <span class="s2">&quot; estimates=[{&#39;function_name&#39;:&quot;</span>
                        <span class="o">+</span> <span class="s2">&quot; user_defined_function}].&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">est_item</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="c1"># If the estimate is a dict, validate each function</span>
                <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">est_item</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">validate_estimation_function</span><span class="p">(</span>
                            <span class="n">function</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                        <span class="n">cleaned_estimates</span> <span class="o">+=</span> <span class="p">[{</span><span class="n">func_name</span><span class="p">:</span> <span class="n">function</span><span class="p">}]</span>
                    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                        <span class="k">continue</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Find all scalar keys in data</span>
        <span class="n">scalarkeys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">scalarkeys</span> <span class="o">+=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found scalar keys for estimation: &quot;</span>
              <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">scalarkeys</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Then only apply estimates to scalars that do not already have them</span>
        <span class="k">for</span> <span class="n">est_item</span> <span class="ow">in</span> <span class="n">estimates</span><span class="p">:</span>
            <span class="c1"># If it&#39;s a string for a predefined function in est_functions</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">est_item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># Is there a scalar without this estimate?</span>
                <span class="n">include_estimate</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">for</span> <span class="n">skey</span> <span class="ow">in</span> <span class="n">scalarkeys</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">skey</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">est_item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                        <span class="n">include_estimate</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>
                <span class="c1"># Include the estimate only if needed and it&#39;s valid</span>
                <span class="k">if</span> <span class="n">include_estimate</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">est_item</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">est_functions</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                        <span class="n">cleaned_estimates</span> <span class="o">+=</span> <span class="p">[</span><span class="n">est_item</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: Estimation function &#39;</span><span class="si">{</span><span class="n">est_item</span><span class="si">}</span><span class="s2">&#39; not &quot;</span>
                            <span class="o">+</span> <span class="s2">&quot;in est_functions, skipping.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Available functions: &quot;</span>
                              <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">est_functions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                              <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;You can add custom functions&quot;</span>
                            <span class="o">+</span> <span class="s2">&quot; estimates=[{&#39;function_name&#39;:&quot;</span>
                            <span class="o">+</span> <span class="s2">&quot; user_defined_function}].&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># If it&#39;s a dict for custom functions</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">est_item</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">est_item</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># Is there a scalar without this estimate?</span>
                    <span class="n">include_estimate</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">skey</span> <span class="ow">in</span> <span class="n">scalarkeys</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">skey</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">func_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                            <span class="n">include_estimate</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>
                    <span class="c1"># Include the estimate only if needed and it&#39;s valid</span>
                    <span class="k">if</span> <span class="n">include_estimate</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">validate_estimation_function</span><span class="p">(</span>
                                <span class="n">function</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
                            <span class="n">cleaned_estimates</span> <span class="o">+=</span> <span class="p">[{</span><span class="n">func_name</span><span class="p">:</span> <span class="n">function</span><span class="p">}]</span>
                        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                            <span class="k">continue</span>
    <span class="n">estimates</span> <span class="o">=</span> <span class="n">cleaned_estimates</span>
    
    <span class="c1"># Only perform variable calculations if lists are not empty</span>
    <span class="k">if</span> <span class="nb">vars</span> <span class="ow">or</span> <span class="n">estimates</span><span class="p">:</span>
        
        <span class="c1"># Transform dict of lists to a list of dicts</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">input_data_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">values</span><span class="p">))</span> 
                           <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>
        <span class="k">del</span> <span class="n">data</span>
        
        <span class="c1"># Calculate first instance</span>
        <span class="n">data_list_i0</span><span class="p">,</span> <span class="n">scalarkeys</span> <span class="o">=</span> <span class="n">process_single_timestep</span><span class="p">(</span>
            <span class="n">input_data_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fd</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">estimates</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rel_kwargs</span><span class="p">)</span>
        <span class="n">data_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_list_i0</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">data_list_i0</span>
        
        <span class="c1"># Calculate all the other</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_data_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            
            <span class="c1"># Sequential processing</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Now processing remaining time steps sequentially&quot;</span><span class="p">,</span>
                    <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="c1"># When redirected, replace \r with \n so progress appears on new lines</span>
            <span class="n">tqdm_kwargs</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">disable_tqdm</span> <span class="k">else</span> <span class="p">{</span>
                <span class="s1">&#39;file&#39;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="p">(),</span> <span class="p">{</span>
                    <span class="s1">&#39;write&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)),</span> 
                    <span class="s1">&#39;flush&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()})()</span>
            <span class="p">}</span>
            <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">process_single_timestep</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">estimates</span><span class="p">,</span> 
                                                <span class="n">veryverbose</span><span class="p">,</span> <span class="n">scalarkeys</span><span class="p">,</span> <span class="n">rel_kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">input_data_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="o">**</span><span class="n">tqdm_kwargs</span><span class="p">)]</span>
            <span class="c1"># Combine and sort the results by temporal_key key</span>
            <span class="n">data_list</span> <span class="o">+=</span> <span class="n">results</span>
        <span class="k">del</span> <span class="n">input_data_list</span>
        <span class="n">data_list_sorted</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">temporal_key</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">data_list</span>
        
        <span class="c1"># Transform list of dicts to a dict of lists</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">data_list_sorted</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_list_sorted</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_list_sorted</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">del</span> <span class="n">data_list_sorted</span>
    
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Done!&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No new variables or estimations requested,&quot;</span>
               <span class="o">+</span> <span class="s2">&quot; returning original data.&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="process_single_timestep">
<a class="viewcode-back" href="../../source/time.html#aurel.time.process_single_timestep">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">process_single_timestep</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">estimates</span><span class="p">,</span> 
                            <span class="n">verbose</span><span class="p">,</span> <span class="n">scalarkeys</span><span class="p">,</span> <span class="n">rel_kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Process a single time step for variable calculation and estimation.</span>
<span class="sd">    </span>
<span class="sd">    This function creates an AurelCore instance for the specified time step,</span>
<span class="sd">    calculates requested variables, and applies estimation </span>
<span class="sd">    functions to 3D arrays if specified.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : dict</span>
<span class="sd">        Dictionary containing variables of relevant iteration. </span>
<span class="sd">        The function will add calculated variables</span>
<span class="sd">        to this dictionary.</span>
<span class="sd">    fd : FiniteDifference</span>
<span class="sd">        Finite difference class used to initialize AurelCore instances.</span>
<span class="sd">    vars : list of str or dict</span>
<span class="sd">        List of variable names to calculate. These variables will be computed</span>
<span class="sd">        using the AurelCore instance at each time step.</span>
<span class="sd">        Elements can be:</span>

<span class="sd">        - str: Names of predefined variables from core.descriptions</span>
<span class="sd">        - dict: Custom variable definitions with string keys (variable names)</span>
<span class="sd">          and functions that take an AurelCore instance and return the variable</span>
<span class="sd">          value.</span>

<span class="sd">        If empty, no variable calculations are performed.</span>
<span class="sd">    estimates : list of str or dict</span>
<span class="sd">        List containing estimation functions to apply to all 3D scalar arrays.</span>
<span class="sd">        Elements can be:</span>

<span class="sd">        - str: Names of predefined functions from est_functions</span>
<span class="sd">        - dict: Custom estimation functions with string keys (function names)</span>
<span class="sd">          and functions that take a 3D array of shape (fd.Nx, fd.Ny, fd.Nz) </span>
<span class="sd">          and return a scalar value.</span>
<span class="sd">        </span>
<span class="sd">        If empty, no estimation applied.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Passed to AurelCore for debug information and calculation process.</span>
<span class="sd">    scalarkeys : list of str</span>
<span class="sd">        List of keys in `data` that contain 3D scalar arrays. If None,</span>
<span class="sd">        the function will determine these keys automatically.</span>
<span class="sd">    rel_kwargs : dict</span>
<span class="sd">        Additional parameters passed to AurelCore initialization.</span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Updated data dictionary with calculated variables.</span>
<span class="sd">        If `vars` is provided, a new key is added containing a list of</span>
<span class="sd">        values for this time step.</span>
<span class="sd">        If `estimates` is provided, additional keys are added with format</span>
<span class="sd">        &#39;{variable}_{estimation_func}&#39;.</span>
<span class="sd">    list of str</span>
<span class="sd">        List of scalar keys if `scalarkeys` is None, otherwise returns None.&quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">temp</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;it&#39;</span><span class="p">,</span> <span class="s1">&#39;iteration&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;time&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">temp</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing </span><span class="si">{</span><span class="n">temp</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">data</span><span class="p">[</span><span class="n">temp</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> 
                      <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">break</span>
    
    <span class="c1"># ====== Calculate vars if requested</span>
    <span class="k">if</span> <span class="nb">vars</span><span class="p">:</span>
        <span class="c1"># Create a new AurelCore instance for this time step</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">AurelCore</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="o">**</span><span class="n">rel_kwargs</span><span class="p">)</span>
        
        <span class="c1"># Set all existing data values for this time step </span>
        <span class="c1"># (except variables to be calculated)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
                <span class="n">rel</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span>
        <span class="c1"># Freeze the data for cache management</span>
        <span class="n">rel</span><span class="o">.</span><span class="n">freeze_data</span><span class="p">()</span>

        <span class="c1"># Implement custom variables if requested</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculating custom variable &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39;...&quot;</span><span class="p">,</span>
                              <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">rel</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">rel</span><span class="p">)</span>
                    <span class="n">rel</span><span class="o">.</span><span class="n">var_importance</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Freeze this in</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculated and freezed variable &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                              <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot; in AurelCore&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Calculate and store each requested variable</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">data</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span>
        
        <span class="c1"># Clean up AurelCore instance to free memory</span>
        <span class="k">del</span> <span class="n">rel</span>

    <span class="c1"># ====== Find all keys that contain 3D scalar arrays</span>
    <span class="c1"># (shape that has 3 dimensions)</span>
    <span class="k">if</span> <span class="n">scalarkeys</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scalarkeys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">scalarkeys</span> <span class="o">+=</span> <span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">return_scalarkeys</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">return_scalarkeys</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="c1"># ====== Apply estimation functions if requested</span>
    <span class="k">if</span> <span class="n">estimates</span><span class="p">:</span>
        
        <span class="c1"># Process each item in the estimates list</span>
        <span class="k">for</span> <span class="n">est_item</span> <span class="ow">in</span> <span class="n">estimates</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">est_item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing estimation item: </span><span class="si">{</span><span class="n">est_item</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> 
                          <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">est_item</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">est_item</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing estimation item: </span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> 
                            <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># For each scalar key, process the estimation functions</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">scalarkeys</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">est_item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">key</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">est_item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                        <span class="c1"># Handle predefined estimation from est_functions</span>
                        <span class="c1"># Apply estimation function and store the result</span>
                        <span class="n">func</span> <span class="o">=</span> <span class="n">est_functions</span><span class="p">[</span><span class="n">est_item</span><span class="p">]</span>
                        <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">est_item</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">est_item</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="c1"># Handle custom estimation functions from dictionary</span>
                    <span class="k">for</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">est_item</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="n">key</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">func_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                            <span class="c1"># Apply the custom estimation function and store </span>
                            <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="o">+</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
    
    <span class="c1"># Return the updated data and scalar keys if new information requested</span>
    <span class="k">if</span> <span class="n">return_scalarkeys</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">scalarkeys</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span></div>

    
<div class="viewcode-block" id="validate_estimation_function">
<a class="viewcode-back" href="../../source/time.html#aurel.time.validate_estimation_function">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">validate_estimation_function</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validate that estimation function has correct signature and behaviour.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        Function to validate</span>
<span class="sd">    func_name : str</span>
<span class="sd">        Name of the function for error messages</span>
<span class="sd">    fd : FiniteDifference</span>
<span class="sd">        Finite difference object to get grid dimensions</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        If True, prints debug information about the validation process.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        True if function is valid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Validating estimation function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39;...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Check if it&#39;s callable</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Estimation function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39; must be callable&quot;</span><span class="p">)</span>
    
    <span class="c1"># Check function signature</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Estimation function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39; must take exactly 1 parameter,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; a scalar array, instead got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    
    <span class="c1"># Test with dummy array</span>
    <span class="n">test_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">fd</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span> <span class="n">fd</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span> <span class="n">fd</span><span class="o">.</span><span class="n">Nz</span><span class="p">))</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">test_array</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Estimation function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39; failed when called with &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;array of shape (</span><span class="si">{</span><span class="n">fd</span><span class="o">.</span><span class="n">Nx</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">fd</span><span class="o">.</span><span class="n">Ny</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">fd</span><span class="o">.</span><span class="n">Nz</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    
    <span class="c1"># Check return type and shape - must be scalar-like</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Convert to Python scalar if possible evaluation</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;item&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">item</span><span class="p">):</span>
            <span class="n">result_value</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result_value</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">result_value</span> <span class="o">=</span> <span class="n">result</span>
    
    <span class="c1"># Check if result is scalar-like: Python scalar or 0-dimensional array</span>
    <span class="n">is_scalar</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">result_value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">))</span> <span class="ow">or</span>  <span class="c1"># Python scalars</span>
        <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">())</span> <span class="ow">or</span>  <span class="c1"># 0-d arrays</span>
        <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>        <span class="c1"># NumPy scalars</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_scalar</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Estimation function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39; must return a scalar, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;got type </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">result</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Custom function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39; validated successfully&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span></div>


<div class="viewcode-block" id="validate_variable_function">
<a class="viewcode-back" href="../../source/time.html#aurel.time.validate_variable_function">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">validate_variable_function</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span>
                               <span class="n">verbose</span><span class="p">,</span> <span class="n">veryverbose</span><span class="p">,</span> <span class="n">rel_kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validate that variable function has correct signature and behaviour.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        Function to validate</span>
<span class="sd">    func_name : str</span>
<span class="sd">        Name of the function for error messages</span>
<span class="sd">    fd : FiniteDifference</span>
<span class="sd">        Finite difference object to get grid dimensions</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        If True, prints debug information about the validation process. </span>
<span class="sd">    veryverbose : bool</span>
<span class="sd">        If True, prints aurelcore verbose information.</span>
<span class="sd">    rel_kwargs : dict</span>
<span class="sd">        Additional parameters passed to AurelCore initialization.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        True if function is valid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Validating variable function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39;...&quot;</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Check if it&#39;s callable</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variable function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39; must be callable&quot;</span><span class="p">)</span>
    
    <span class="c1"># Check function signature</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Variable function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39; must take exactly 1 parameter,&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; the AurelCore class, instead got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    
    <span class="c1"># Test with dummy AurelCore instance</span>
    <span class="n">rel</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">AurelCore</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">veryverbose</span><span class="p">,</span> <span class="o">**</span><span class="n">rel_kwargs</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">rel</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">rel</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Variable function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39; failed when called with &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;AurelCore instance: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; Custom function &#39;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2">&#39; validated successfully&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">True</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Robyn L. Munoz.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>