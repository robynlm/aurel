{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "220c43dd",
   "metadata": {},
   "source": [
    "# Example symbolic\n",
    "\n",
    "The symbolic part of aurel uses sympy and provides extra tensorial calculations using the automatic aurel process. So let's first load those two packages."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "6900bd59",
   "metadata": {},
   "outputs": [],
   "source": [
    "import sympy as sp\n",
    "import aurel\n",
    "from IPython.display import display"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "883d176d",
   "metadata": {},
   "source": [
    "The coordinates of the spacetime need to be provided. Here since it is symbolic this is not limited to Cartesian and handle more or less than four dimensions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "1bf1542a",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Coordinate setup\n",
    "coords = sp.symbols('t r theta phi')\n",
    "t, r, theta, phi = coords\n",
    "\n",
    "# Create AurelCoreSymbolic object\n",
    "relsym = aurel.AurelCoreSymbolic(\n",
    "    coords,\n",
    "    verbose = True, # Default, shows calculation steps\n",
    "    simplify = True # Enable simplification during calculations\n",
    "    )"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "79cd4a65",
   "metadata": {},
   "source": [
    "Like in the main AurelCore class, the base terms need to be provided otherwise assumptions are made. Here the specific assumption depends on the number of dimensions; if the are 4-dimensions, the assumption is Minkowski $g_{\\alpha\\beta} = \\eta_{\\alpha\\beta}$, if there are 3-dimensions, the assumption is $g_{ij} = \\delta_{ij}$, otherwise there is no support and AurelCoreSymbolic.data['gdown'] needs to be provided.\n",
    "\n",
    "For this example lets use the Schwarzschild metric."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "eb6f01fd",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\left[\\begin{matrix}\\frac{2 M}{r} - 1 & 0 & 0 & 0\\\\0 & \\frac{1}{- \\frac{2 M}{r} + 1} & 0 & 0\\\\0 & 0 & r^{2} & 0\\\\0 & 0 & 0 & r^{2} \\sin^{2}{\\left(\\theta \\right)}\\end{matrix}\\right]$"
      ],
      "text/plain": [
       "Matrix([\n",
       "[2*M/r - 1,              0,    0,                  0],\n",
       "[        0, 1/(-2*M/r + 1),    0,                  0],\n",
       "[        0,              0, r**2,                  0],\n",
       "[        0,              0,    0, r**2*sin(theta)**2]])"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Spacetime\n",
    "M = sp.symbols('M', real=True, positive=True)\n",
    "relsym.data['gdown'] = sp.Matrix([\n",
    "    [- (1 - (2 * M / r)), 0, 0, 0],\n",
    "    [ 0, 1/(1 - (2 * M / r)), 0, 0],\n",
    "    [ 0, 0, r**2, 0],\n",
    "    [ 0, 0, 0, r**2 * sp.sin(theta)**2]\n",
    "        ])\n",
    "relsym['gdown']"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "916e6171",
   "metadata": {},
   "source": [
    "From here on you can directly call any of the currently implemented terms. Say the Ricci Scalar:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "7a45b8a3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Calculated symbolic gup: Metric tensor in the up index form\n",
      "Calculated symbolic Gamma_udd: Christoffel symbols in the up-down-down index form\n",
      "Calculated symbolic Ricci_down: Ricci curvature tensor in the down index form\n",
      "Calculated symbolic RicciS: Ricci scalar\n"
     ]
    },
    {
     "data": {
      "text/latex": [
       "$\\displaystyle 0$"
      ],
      "text/plain": [
       "0"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "relsym['RicciS']"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ef845a78",
   "metadata": {},
   "source": [
    "For non scalars, the indicies are reflected in the shape, and the components can be individually called."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "f1311060",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\left( 4, \\  4, \\  4\\right)$"
      ],
      "text/plain": [
       "(4, 4, 4)"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "relsym['Gamma_udd'].shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "def8fbc3",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\Gamma^0_{01} = - \\frac{1.0 M}{r \\left(2 M - r\\right)}$"
      ],
      "text/plain": [
       "Eq(\\Gamma^0_{01}, -1.0*M/(r*(2*M - r)))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\Gamma^1_{00} = - \\frac{1.0 M \\left(2 M - r\\right)}{r^{3}}$"
      ],
      "text/plain": [
       "Eq(\\Gamma^1_{00}, -1.0*M*(2*M - r)/r**3)"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\Gamma^1_{11} = \\frac{1.0 M}{r \\left(2 M - r\\right)}$"
      ],
      "text/plain": [
       "Eq(\\Gamma^1_{11}, 1.0*M/(r*(2*M - r)))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\Gamma^1_{22} = 2.0 M - 1.0 r$"
      ],
      "text/plain": [
       "Eq(\\Gamma^1_{22}, 2.0*M - 1.0*r)"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\Gamma^1_{33} = \\left(2.0 M - 1.0 r\\right) \\sin^{2}{\\left(\\theta \\right)}$"
      ],
      "text/plain": [
       "Eq(\\Gamma^1_{33}, (2.0*M - 1.0*r)*sin(theta)**2)"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\Gamma^2_{12} = \\frac{1.0}{r}$"
      ],
      "text/plain": [
       "Eq(\\Gamma^2_{12}, 1.0/r)"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\Gamma^2_{33} = - 0.5 \\sin{\\left(2 \\theta \\right)}$"
      ],
      "text/plain": [
       "Eq(\\Gamma^2_{33}, -0.5*sin(2*theta))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\Gamma^3_{13} = \\frac{1.0}{r}$"
      ],
      "text/plain": [
       "Eq(\\Gamma^3_{13}, 1.0/r)"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "data": {
      "text/latex": [
       "$\\displaystyle \\Gamma^3_{23} = \\frac{1.0}{\\tan{\\left(\\theta \\right)}}$"
      ],
      "text/plain": [
       "Eq(\\Gamma^3_{23}, 1.0/tan(theta))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "for i in range(relsym.dim):\n",
    "    for j in range(relsym.dim):\n",
    "        for k in range(j, relsym.dim):\n",
    "            if relsym['Gamma_udd'][i, j, k] != 0:\n",
    "                display(sp.Eq(sp.Symbol(f\"\\\\Gamma^{i}_{{{j}{k}}}\"), \n",
    "                              relsym['Gamma_udd'][i, j, k]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "be49b9c3",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.14.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
